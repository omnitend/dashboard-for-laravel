---
layout: ../../../layouts/DashboardLayout.astro
title: DXTable
---

import ComponentExample from '../../../components/ComponentExample.vue';
import DXTableExample from '../../../examples/DXTableExample.vue';
import PropsTable from '../../../components/PropsTable.vue';
import EventsTable from '../../../components/EventsTable.vue';
import SlotsTable from '../../../components/SlotsTable.vue';

# DXTable

A comprehensive data table component with built-in pagination, loading states, and error handling for Laravel dashboards.

## Live Examples

<ComponentExample
  client:only="vue"
  code={`<script setup>
import { ref } from 'vue';
import { DXTable } from '@omnitend/dashboard-for-laravel';

const customerFields = [
  { key: 'id', label: 'ID', sortable: true },
  { key: 'name', label: 'Name', sortable: true },
  { key: 'email', label: 'Email' },
  { key: 'company', label: 'Company', sortable: true },
  { key: 'status', label: 'Status' },
];

const customerItems = ref([
  { id: 1, name: 'John Smith', email: 'john@example.com', company: 'Acme Ltd', status: 'Active' },
  { id: 2, name: 'Jane Doe', email: 'jane@example.com', company: 'Tech Corp', status: 'Active' },
  { id: 3, name: 'Bob Johnson', email: 'bob@example.com', company: 'Global Industries', status: 'Inactive' },
  { id: 4, name: 'Alice Williams', email: 'alice@example.com', company: 'Digital Solutions', status: 'Active' },
  { id: 5, name: 'Charlie Brown', email: 'charlie@example.com', company: 'Cloud Systems', status: 'Pending' },
]);

const paginationData = ref({
  currentPage: 1,
  perPage: 10,
  total: 5,
  from: 1,
  to: 5,
});
</script>

<template>
  <DXTable
    :items="customerItems"
    :fields="customerFields"
    :pagination="paginationData"
    title="Customers"
  />
</template>`}
>
  <DXTableExample client:load />
</ComponentExample>

## Props

<PropsTable client:load props={[
  { name: 'title', type: 'string', required: 'No', default: '-', description: 'Table title' },
  { name: 'itemName', type: 'string', required: 'No', default: 'item', description: 'Singular item name (auto-pluralized for display)' },
  { name: 'items', type: 'TItem[]', required: 'No', default: '-', description: 'Table data items (Inertia mode)' },
  { name: 'provider', type: 'BTableProvider<TItem>', required: 'No', default: '-', description: 'Provider function for API mode' },
  { name: 'apiUrl', type: 'string', required: 'No', default: '-', description: 'API endpoint URL for auto-provider mode' },
  { name: 'fields', type: 'TableField[]', required: 'Yes', default: '-', description: 'Table field definitions (see TableField interface)' },
  { name: 'sortBy', type: 'BTableSortBy[]', required: 'No', default: '[]', description: 'Sort configuration (v-model support)' },
  { name: 'filters', type: 'Record<string, string>', required: 'No', default: '{}', description: 'Filter values (v-model support)' },
  { name: 'filterValues', type: 'Record<string, string[]>', required: 'No', default: '-', description: 'Dynamic filter options from server' },
  { name: 'inertiaUrl', type: 'string', required: 'No', default: '-', description: 'Inertia route URL (enables auto-navigation)' },
  { name: 'busy', type: 'boolean', required: 'No', default: 'false', description: 'Loading/busy state (v-model support, API mode)' },
  { name: 'loading', type: 'boolean', required: 'No', default: 'false', description: 'Loading state (Inertia mode, deprecated - use busy)' },
  { name: 'loadingText', type: 'string', required: 'No', default: 'Loading...', description: 'Loading text' },
  { name: 'error', type: 'string | null', required: 'No', default: 'null', description: 'Error message' },
  { name: 'pagination', type: 'PaginationData', required: 'No', default: 'function', description: 'Pagination data (Inertia mode)' },
  { name: 'showPagination', type: 'boolean', required: 'No', default: 'true', description: 'Show pagination controls' },
  { name: 'showPerPageSelector', type: 'boolean', required: 'No', default: 'true', description: 'Show per-page selector' },
  { name: 'perPageOptions', type: 'number[]', required: 'No', default: '[10, 25, 50, 100]', description: 'Per-page options for selector' },
  { name: 'currentPage', type: 'number', required: 'No', default: '1', description: 'Current page (for provider mode)' },
  { name: 'perPage', type: 'number', required: 'No', default: '10', description: 'Items per page (v-model support)' },
  { name: 'striped', type: 'boolean', required: 'No', default: 'true', description: 'Striped rows' },
  { name: 'hover', type: 'boolean', required: 'No', default: 'true', description: 'Hover effect on rows' },
  { name: 'responsive', type: 'boolean', required: 'No', default: 'true', description: 'Responsive table' },
  { name: 'fluid', type: 'boolean', required: 'No', default: 'false', description: 'Fluid container' },
  { name: 'containerClass', type: 'string', required: 'No', default: 'py-5', description: 'Container CSS class' },
  { name: 'columnSize', type: 'string | number', required: 'No', default: '12', description: 'Column size (Bootstrap grid)' },
  { name: 'editFields', type: 'FieldDefinition[]', required: 'No', default: '-', description: 'Form fields for edit modal (enables edit on row click)' },
  { name: 'editTabs', type: 'EditTab[]', required: 'No', default: '-', description: 'Tab definitions for organizing edit modal content' },
  { name: 'editModalTitle', type: 'string | ((item: any) => string)', required: 'No', default: '-', description: 'Edit modal title (string or function)' },
  { name: 'editModalSize', type: 'sm | md | lg | xl', required: 'No', default: 'lg', description: 'Edit modal size' },
  { name: 'editUrl', type: 'string', required: 'No', default: '-', description: 'API endpoint pattern for updates (e.g., "/api/products/:id")' },
  { name: 'deleteUrl', type: 'string', required: 'No', default: '-', description: 'API endpoint pattern for deletions (e.g., "/api/products/:id")' },
]} />

## Events

<EventsTable client:load events={[
  { name: 'pageChange', params: 'page: number', description: 'Emitted when the page changes' },
  { name: 'sortChange', params: 'sort: { key: string, order: "asc" | "desc" }', description: 'Emitted when sort changes' },
  { name: 'filterChange', params: 'filters: Record<string, string>', description: 'Emitted when filters change' },
  { name: 'perPageChange', params: 'perPage: number', description: 'Emitted when per-page value changes' },
  { name: 'rowClicked', params: 'item: T, index: number, event: MouseEvent', description: 'Emitted when a row is clicked' },
  { name: 'rowUpdated', params: 'item: T, response: any', description: 'Emitted when a row is successfully updated' },
  { name: 'editError', params: 'item: T, error: any', description: 'Emitted when row update fails' },
  { name: 'rowDeleted', params: 'item: T, response: any', description: 'Emitted when a row is successfully deleted' },
  { name: 'deleteError', params: 'item: T, error: any', description: 'Emitted when row deletion fails' },
  { name: 'update:sortBy', params: 'sortBy: BTableSortBy[]', description: 'v-model update for sortBy' },
  { name: 'update:filters', params: 'filters: Record<string, string>', description: 'v-model update for filters' },
  { name: 'update:perPage', params: 'perPage: number', description: 'v-model update for perPage' },
  { name: 'update:busy', params: 'busy: boolean', description: 'v-model update for busy state' },
]} />

## Slots

<SlotsTable client:load slots={[
  { name: 'header', description: 'Custom header content' },
]} />

## Server-Side Pagination

DXTable works seamlessly with Laravel's pagination and the package's `PaginatedResource` helper.

### Laravel Backend Setup

Use the `PaginatedResource` to format your paginated data:

```php
<?php

namespace App\Http\Controllers;

use App\Models\Product;
use Illuminate\Http\Request;
use Inertia\Inertia;
use OmniTend\LaravelDashboard\Http\Resources\PaginatedResource;

class ProductController extends Controller
{
    public function index(Request $request)
    {
        $perPage = $request->input('perPage', 10);
        $products = Product::orderBy('created_at', 'desc')->paginate($perPage);

        return Inertia::render('Products/Index', [
            'products' => new PaginatedResource($products),
        ]);
    }
}
```

### Vue Frontend Implementation

```vue
<script setup lang="ts">
import { DXTable } from '@omnitend/dashboard-for-laravel';
import type { PaginationData } from '@omnitend/dashboard-for-laravel';

interface Product {
  id: number;
  sku: string;
  name: string;
  price: string;
  stock: number;
}

interface Props {
  products: PaginationData & { data: Product[] };
}

defineProps<Props>();

const fields = [
  { key: 'sku', label: 'SKU', sortable: true },
  { key: 'name', label: 'Name', sortable: true },
  { key: 'price', label: 'Price', sortable: true },
  { key: 'stock', label: 'Stock', sortable: true },
];
</script>

<template>
  <DXTable
    title="Products"
    :items="products.data"
    :fields="fields"
    :pagination="products"
    inertia-url="/"
  />
</template>
```

Or create a reusable type helper:

```typescript
// types/index.ts
export interface PaginatedData<T> {
  data: T[];
  current_page: number;
  per_page: number;
  total: number;
  from: number;
  to: number;
  last_page: number;
}

// Your page component
import type { PaginatedData } from '@/types';

interface Props {
  products: PaginatedData<Product>;
}
```

**That's it!** Just pass `inertia-url` and DXTable handles everything:
- Sorting (click column headers)
- Pagination (click page numbers)
- Filtering (inline inputs beneath headers)
- State preservation
- Server requests with correct parameters

No handlers, no refs, no boilerplate!

### Adding Filters

Add inline filters by specifying `filter` in field definitions:

```typescript
const fields = [
  { key: 'sku', label: 'SKU', sortable: true },
  { key: 'name', label: 'Name', sortable: true, filter: 'text' },
  { key: 'category', label: 'Category', sortable: true, filter: 'select', filterOptions: [
    { value: 'Electronics', text: 'Electronics' },
    { value: 'Clothing', text: 'Clothing' },
    { value: 'Books', text: 'Books' },
  ]},
  { key: 'price', label: 'Price', sortable: true, filter: 'number' },
  { key: 'stock', label: 'Stock', sortable: true, filter: 'number' },
];
```

**Filter Types:**
- `'text'` - Text input with 300ms debounce for LIKE searches
- `'select'` - Dropdown with options (automatically adds "All" option)
- `'number'` - Number input for exact matches
- `'date'` - Date input for date filtering
- `false` or omit - No filter for this column

Filters appear inline beneath the table headers and trigger server requests automatically.

### Field Hints

Add helpful hint text below column headers to guide users:

```typescript
const fields = [
  { key: 'sku', label: 'SKU', sortable: true, hint: 'Product code' },
  { key: 'name', label: 'Name', sortable: true, filter: 'text', hint: 'Search by name' },
  { key: 'price', label: 'Price', sortable: true, hint: 'USD', formatter: (value) => `$${value}` },
  { key: 'stock', label: 'Stock', sortable: true, hint: 'Current inventory' },
];
```

**Features:**
- Hint text appears below the column label in a smaller, muted font
- Works with sortable columns (hint appears above sort indicators)
- Works with filters (hint appears in column header, above filter input)
- Useful for units (USD, kg), instructions (Search by name), or context (Current inventory)
- Optional - only shows when `hint` property is provided

**Example Output:**
```
Product Name    Price
Search by name  USD
↑↓              ↑↓
[filter input]  [filter input]
```

### Backend Filter Handling

Update your controller to accept and apply filters:

```php
public function index(Request $request)
{
    // ... sorting code ...

    // Build query with filters
    $query = Product::query();

    // Apply filters
    $filters = $request->input('filters', []);

    // Text filters (LIKE search)
    if (!empty($filters['name'])) {
        $query->where('name', 'LIKE', '%' . $filters['name'] . '%');
    }

    // Exact match filters
    if (!empty($filters['category'])) {
        $query->where('category', $filters['category']);
    }

    if (!empty($filters['price'])) {
        $query->where('price', '=', $filters['price']);
    }

    $products = $query->orderBy($sortBy, $sortOrder)->paginate($perPage);

    return Inertia::render('Products/Index', [
        'products' => new PaginatedResource($products),
    ]);
}
```

**Filter Behavior:**
- Text filters automatically debounce (300ms) to reduce server load
- Filtering resets to page 1
- Empty filters are removed from request
- Filters preserve sort state
- Works identically in both Inertia and API modes

### Key Points

- **Batteries Included**: Just pass `inertia-url` - DXTable handles all sorting and pagination automatically
- **PaginatedResource**: Returns data in the exact format DXTable expects (snake_case Laravel convention)
- **No Boilerplate**: No need to write handlers, manage sortBy refs, or handle events
- **Single-Column Sort**: Automatically normalizes multi-column sorts to single-column for Laravel
- **Server-Side Only**: Disables client-side sorting (`:no-local-sorting="true"`) automatically
- **State Preservation**: Uses `preserveState: true` for smooth navigation
- **Security**: Always whitelist allowed sort columns on the backend
- **Snake Case Properties**: Uses `current_page`, `per_page`, `total`, `from`, `to`, `last_page` to match Laravel conventions

### Advanced Usage (Custom Handlers)

If you need custom behavior, you can still handle events manually by omitting `inertia-url`:

```vue
<DXTable
  :items="products.data"
  :fields="fields"
  :pagination="products"
  @page-change="customPageHandler"
  @sort-change="customSortHandler"
/>
```

## API Mode (Provider Pattern)

DXTable also supports the traditional AJAX/API pattern using Bootstrap-Vue-Next's provider functionality. This is perfect for:
- Migrating from Bootstrap-Vue (Vue 2) to modern stack
- Existing Laravel apps with API endpoints
- SPAs that don't use Inertia.js

### Laravel Backend (API Endpoint)

```php
<?php

namespace App\Http\Controllers;

use App\Models\Product;
use Illuminate\Http\Request;

class ProductController extends Controller
{
    public function apiIndex(Request $request)
    {
        $page = $request->input('page', 1);
        $perPage = $request->input('perPage', 10);
        $sortBy = $request->input('sortBy', 'created_at');
        $sortOrder = $request->input('sortOrder', 'desc');

        // Whitelist allowed sort columns for security
        $allowedSortColumns = ['sku', 'name', 'price', 'stock', 'created_at'];

        if (!in_array($sortBy, $allowedSortColumns)) {
            $sortBy = 'created_at';
        }

        if (!in_array(strtolower($sortOrder), ['asc', 'desc'])) {
            $sortOrder = 'desc';
        }

        $products = Product::orderBy($sortBy, $sortOrder)
            ->paginate($perPage, ['*'], 'page', $page);

        return response()->json([
            'data' => $products->items(),
            'pagination' => [
                'current_page' => $products->currentPage(),
                'per_page' => $products->perPage(),
                'total' => $products->total(),
                'from' => $products->firstItem(),
                'to' => $products->lastItem(),
                'last_page' => $products->lastPage(),
            ],
        ]);
    }
}
```

**Route:**
```php
// routes/api.php
Route::get('/products', [ProductController::class, 'apiIndex']);
```

### Vue Frontend (Simple API Mode)

```vue
<script setup lang="ts">
import { ref } from 'vue';
import { DXTable } from '@omnitend/dashboard-for-laravel';

const fields = [
  { key: 'sku', label: 'SKU', sortable: true },
  { key: 'name', label: 'Name', sortable: true },
  { key: 'price', label: 'Price', sortable: true },
  { key: 'stock', label: 'Stock', sortable: true },
];

const busy = ref(false);
</script>

<template>
  <DXTable
    title="Products"
    api-url="/api/products"
    :fields="fields"
    v-model:busy="busy"
    :per-page="10"
  />
</template>
```

**That's it!** Just pass `api-url` and DXTable handles:
- AJAX requests with axios
- Sorting parameters
- Pagination parameters
- Data extraction from `response.data.data`
- Error handling

### Advanced: Custom Provider Function

For custom API logic (auth headers, data transformation, etc.), provide your own `provider`:

```vue
<script setup>
const customProvider = async (context) => {
  const response = await fetch('/api/products', {
    headers: { 'Authorization': `Bearer ${token}` },
    ...
  });
  const json = await response.json();
  return json.items; // Custom response structure
};
</script>

<template>
  <DXTable :provider="customProvider" :fields="fields" />
</template>
```

### Key Differences: Inertia vs API Mode

| Feature | Inertia Mode | API Mode |
|---------|--------------|----------|
| **Prop** | `inertia-url="/"` | `api-url="/api/products"` |
| **Data Source** | `:items` + `:pagination` | Auto-fetched via axios |
| **Pagination** | Server-side with Inertia | BTable via `:per-page` |
| **Sorting** | Server-side with Inertia | Auto-handled by provider |
| **Loading State** | `:loading` prop | `v-model:busy` |
| **URL Updates** | Yes (full page navigation) | No (AJAX only) |
| **Backend** | Inertia render + PaginatedResource | JSON endpoint |
| **Best For** | Modern Laravel + Inertia | Traditional SPAs, Bootstrap-Vue migrations |
| **Setup** | 1 line | 1 line |

### Provider Function Details

The provider function receives a context object:

```typescript
interface BTableProviderContext {
  sortBy?: BTableSortBy[];      // Current sort state
  filter?: string;               // Filter string (if filtering enabled)
  currentPage: number;           // Current page number
  perPage: number;               // Items per page
}
```

**Important:**
- Return an array of items (or Promise that resolves to array)
- BTable handles pagination UI automatically
- No need to show "Showing X to Y" text (provider mode)
- Sorting and pagination trigger automatic provider calls

### Manual Refresh

Access the `refresh()` method for manual data reloading:

```vue
<script setup>
import { ref } from 'vue';

const tableRef = ref(null);

const refreshData = () => {
  tableRef.value?.refresh();
};
</script>

<template>
  <DButton @click="refreshData">Refresh</DButton>
  <DXTable
    ref="tableRef"
    :provider="fetchProducts"
    :fields="fields"
  />
</template>
```

## TableField Interface

Fields support the following properties:

```typescript
interface TableField {
  key: string;                    // Required: Field key (matches data property)
  label?: string;                 // Column header label
  sortable?: boolean;             // Enable sorting for this column
  hint?: string;                  // Hint text below column header
  filter?: FilterType;            // Filter type: 'text' | 'select' | 'number' | 'date' | false
  filterOptions?: FilterOption[]; // Options for select filters
  filterPlaceholder?: string;     // Placeholder for filter input
  formatter?: (value: any, key: string, item: any) => string; // Custom formatter function
  [key: string]: any;             // Any other Bootstrap Vue Next BTable field props
}
```

## Edit Modals

Enable inline editing by providing `editFields` and `editUrl`:

```vue
<script setup>
const fields = [
  { key: 'name', label: 'Product Name', sortable: true },
  { key: 'price', label: 'Price', sortable: true },
];

const editFields = [
  { key: 'name', label: 'Product Name', type: 'text', required: true },
  { key: 'description', label: 'Description', type: 'textarea' },
  { key: 'price', label: 'Price', type: 'number', required: true },
  { key: 'stock', label: 'Stock', type: 'number', required: true },
];
</script>

<template>
  <DXTable
    :items="products.data"
    :fields="fields"
    :edit-fields="editFields"
    edit-url="/api/products/:id"
    edit-modal-title="Edit Product"
  />
</template>
```

**Features:**
- Click any row to open edit modal
- Form fields auto-populated from row data
- Save button submits PUT request to `editUrl` (`:id` replaced with item.id)
- Success/error toasts shown automatically
- Table refreshes after successful save
- Validation errors displayed inline

## Delete Functionality

Enable deletion with the `deleteUrl` prop:

```vue
<template>
  <DXTable
    :items="products.data"
    :fields="fields"
    :edit-fields="editFields"
    edit-url="/api/products/:id"
    delete-url="/api/products/:id"
    @row-deleted="handleDeleted"
    @delete-error="handleDeleteError"
  />
</template>
```

**Features:**
- Delete button appears in modal footer (red/danger variant)
- Confirmation dialog before deletion
- Success/error toasts with server messages
- Table auto-refreshes after successful deletion
- Displays server validation errors (e.g., "Cannot delete. This category has 42 products.")

**Backend Example:**
```php
public function destroy(Product $product)
{
    // Optional: Add validation
    if ($product->orders()->count() > 0) {
        return response()->json([
            'message' => "Cannot delete {$product->name}. This product has orders.",
        ], 422);
    }

    $product->delete();

    return response()->json([
        'success' => true,
        'message' => 'Product deleted successfully',
    ]);
}
```

## Extended Component

This is a custom component that extends beyond simple Bootstrap Vue Next wrappers,
providing additional functionality specific to Laravel dashboards.
