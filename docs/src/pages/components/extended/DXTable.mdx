---
layout: ../../../layouts/DashboardLayout.astro
title: DXTable
---

import ComponentExample from '../../../components/ComponentExample.vue';
import DXTableExample from '../../../examples/DXTableExample.vue';
import PropsTable from '../../../components/PropsTable.vue';
import EventsTable from '../../../components/EventsTable.vue';
import SlotsTable from '../../../components/SlotsTable.vue';

# DXTable

A comprehensive data table component with built-in pagination, sorting, filtering, and CRUD operations for Laravel dashboards.

## Data Fetching Modes

DXTable supports two modes for loading data. **API mode is recommended** for most applications.

| Mode | Prop | Best For |
|------|------|----------|
| **API Mode** (Recommended) | `api-url="/api/products"` | Most applications. Clean separation, reusable endpoints, better caching. |
| Inertia Mode | `inertia-url="/" + :items` | Apps already using Inertia.js with server-side page props. |

### Quick Comparison

| Feature | API Mode | Inertia Mode |
|---------|----------|--------------|
| **Setup** | 1 prop: `api-url` | 3 props: `items`, `pagination`, `inertia-url` |
| **Data Source** | Auto-fetched via axios | Passed as page props |
| **Sorting/Pagination** | Automatic AJAX | Full page reload via Inertia |
| **URL Changes** | No (AJAX only) | Yes (browser URL updates) |
| **Loading State** | `v-model:busy` | `:loading` prop |
| **Backend** | JSON API endpoint | Inertia render + PaginatedResource |

## Live Example

<ComponentExample
  client:load
  code={`<script setup>
import { ref } from 'vue';
import { DXTable } from '@omnitend/dashboard-for-laravel';

// API Mode: Just provide api-url and fields
// The component handles fetching, pagination, and sorting automatically
const fields = [
  { key: 'id', label: 'ID', sortable: true },
  { key: 'name', label: 'Name', sortable: true },
  { key: 'email', label: 'Email' },
  { key: 'company', label: 'Company', sortable: true },
  { key: 'status', label: 'Status' },
];

const busy = ref(false);
</script>

<template>
  <!-- API Mode (Recommended) -->
  <DXTable
    title="Customers"
    api-url="/api/customers"
    :fields="fields"
    v-model:busy="busy"
  />
</template>`}
  example="DXTableExample"
/>

## Props

<PropsTable client:load props={[
  { name: 'title', type: 'string', required: 'No', default: '-', description: 'Table title' },
  { name: 'itemName', type: 'string', required: 'No', default: 'item', description: 'Singular item name (auto-pluralized for display)' },
  { name: 'items', type: 'TItem[]', required: 'No', default: '-', description: 'Table data items (Inertia mode)' },
  { name: 'provider', type: 'BTableProvider<TItem>', required: 'No', default: '-', description: 'Provider function for API mode' },
  { name: 'apiUrl', type: 'string', required: 'No', default: '-', description: 'API endpoint URL for auto-provider mode' },
  { name: 'fields', type: 'TableField[]', required: 'Yes', default: '-', description: 'Table field definitions (see TableField interface)' },
  { name: 'sortBy', type: 'BTableSortBy[]', required: 'No', default: '[]', description: 'Sort configuration (v-model support)' },
  { name: 'filters', type: 'Record<string, string>', required: 'No', default: '{}', description: 'Filter values (v-model support)' },
  { name: 'filterValues', type: 'Record<string, string[]>', required: 'No', default: '-', description: 'Dynamic filter options from server' },
  { name: 'inertiaUrl', type: 'string', required: 'No', default: '-', description: 'Inertia route URL (enables auto-navigation)' },
  { name: 'busy', type: 'boolean', required: 'No', default: 'false', description: 'Loading/busy state (v-model support, API mode)' },
  { name: 'loading', type: 'boolean', required: 'No', default: 'false', description: 'Loading state (Inertia mode, deprecated - use busy)' },
  { name: 'loadingText', type: 'string', required: 'No', default: 'Loading...', description: 'Loading text' },
  { name: 'error', type: 'string | null', required: 'No', default: 'null', description: 'Error message' },
  { name: 'pagination', type: 'PaginationData', required: 'No', default: 'function', description: 'Pagination data (Inertia mode)' },
  { name: 'showPagination', type: 'boolean', required: 'No', default: 'true', description: 'Show pagination controls' },
  { name: 'showPerPageSelector', type: 'boolean', required: 'No', default: 'true', description: 'Show per-page selector' },
  { name: 'perPageOptions', type: 'number[]', required: 'No', default: '[10, 25, 50, 100]', description: 'Per-page options for selector' },
  { name: 'currentPage', type: 'number', required: 'No', default: '1', description: 'Current page (for provider mode)' },
  { name: 'perPage', type: 'number', required: 'No', default: '10', description: 'Items per page (v-model support)' },
  { name: 'striped', type: 'boolean', required: 'No', default: 'true', description: 'Striped rows' },
  { name: 'hover', type: 'boolean', required: 'No', default: 'true', description: 'Hover effect on rows' },
  { name: 'responsive', type: 'boolean', required: 'No', default: 'true', description: 'Responsive table' },
  { name: 'fluid', type: 'boolean', required: 'No', default: 'false', description: 'Fluid container' },
  { name: 'containerClass', type: 'string', required: 'No', default: 'py-5', description: 'Container CSS class' },
  { name: 'columnSize', type: 'string | number', required: 'No', default: '12', description: 'Column size (Bootstrap grid)' },
  { name: 'editFields', type: 'FieldDefinition[]', required: 'No', default: '-', description: 'Form fields for edit modal (enables edit on row click)' },
  { name: 'editTabs', type: 'EditTab[]', required: 'No', default: '-', description: 'Tab definitions for organizing edit modal content' },
  { name: 'editModalTitle', type: 'string | ((item: any) => string)', required: 'No', default: '-', description: 'Edit modal title (string or function)' },
  { name: 'editModalSize', type: 'sm | md | lg | xl', required: 'No', default: 'lg', description: 'Edit modal size' },
  { name: 'editUrl', type: 'string', required: 'No', default: '-', description: 'API endpoint pattern for updates (e.g., "/api/products/:id")' },
  { name: 'deleteUrl', type: 'string', required: 'No', default: '-', description: 'API endpoint pattern for deletions (e.g., "/api/products/:id")' },
]} />

## Events

<EventsTable client:load events={[
  { name: 'pageChange', params: 'page: number', description: 'Emitted when the page changes' },
  { name: 'sortChange', params: 'sort: { key: string, order: "asc" | "desc" }', description: 'Emitted when sort changes' },
  { name: 'filterChange', params: 'filters: Record<string, string>', description: 'Emitted when filters change' },
  { name: 'perPageChange', params: 'perPage: number', description: 'Emitted when per-page value changes' },
  { name: 'rowClicked', params: 'item: T, index: number, event: MouseEvent', description: 'Emitted when a row is clicked' },
  { name: 'rowUpdated', params: 'item: T, response: any', description: 'Emitted when a row is successfully updated' },
  { name: 'editError', params: 'item: T, error: any', description: 'Emitted when row update fails' },
  { name: 'rowDeleted', params: 'item: T, response: any', description: 'Emitted when a row is successfully deleted' },
  { name: 'deleteError', params: 'item: T, error: any', description: 'Emitted when row deletion fails' },
  { name: 'update:sortBy', params: 'sortBy: BTableSortBy[]', description: 'v-model update for sortBy' },
  { name: 'update:filters', params: 'filters: Record<string, string>', description: 'v-model update for filters' },
  { name: 'update:perPage', params: 'perPage: number', description: 'v-model update for perPage' },
  { name: 'update:busy', params: 'busy: boolean', description: 'v-model update for busy state' },
]} />

## Slots

<SlotsTable client:load slots={[
  { name: 'header', description: 'Custom header content' },
]} />

## API Mode (Recommended)

API mode is the recommended approach for most applications. Just provide an `api-url` and DXTable handles everything: fetching data, pagination, sorting, and loading states.

### Why API Mode?

- **Simpler setup** - One prop instead of three
- **Better separation** - Your API is independent of your UI framework
- **Reusable endpoints** - Same API works for mobile apps, other frontends, etc.
- **Better caching** - JSON responses cache more efficiently than full page responses
- **No framework lock-in** - Works whether you use Inertia, traditional Blade, or a pure SPA

### Laravel Backend (API Endpoint)

```php
<?php

namespace App\Http\Controllers;

use App\Models\Product;
use Illuminate\Http\Request;

class ProductController extends Controller
{
    public function apiIndex(Request $request)
    {
        $page = $request->input('page', 1);
        $perPage = $request->input('perPage', 10);
        $sortBy = $request->input('sortBy', 'created_at');
        $sortOrder = $request->input('sortOrder', 'desc');

        // Whitelist allowed sort columns for security
        $allowedSortColumns = ['sku', 'name', 'price', 'stock', 'created_at'];

        if (!in_array($sortBy, $allowedSortColumns)) {
            $sortBy = 'created_at';
        }

        if (!in_array(strtolower($sortOrder), ['asc', 'desc'])) {
            $sortOrder = 'desc';
        }

        $products = Product::orderBy($sortBy, $sortOrder)
            ->paginate($perPage, ['*'], 'page', $page);

        return response()->json([
            'data' => $products->items(),
            'pagination' => [
                'current_page' => $products->currentPage(),
                'per_page' => $products->perPage(),
                'total' => $products->total(),
                'from' => $products->firstItem(),
                'to' => $products->lastItem(),
                'last_page' => $products->lastPage(),
            ],
        ]);
    }
}
```

**Route:**
```php
// routes/api.php
Route::get('/products', [ProductController::class, 'apiIndex']);
```

### Vue Frontend (Simple API Mode)

```vue
<script setup lang="ts">
import { ref } from 'vue';
import { DXTable } from '@omnitend/dashboard-for-laravel';

const fields = [
  { key: 'sku', label: 'SKU', sortable: true },
  { key: 'name', label: 'Name', sortable: true },
  { key: 'price', label: 'Price', sortable: true },
  { key: 'stock', label: 'Stock', sortable: true },
];

const busy = ref(false);
</script>

<template>
  <DXTable
    title="Products"
    api-url="/api/products"
    :fields="fields"
    v-model:busy="busy"
    :per-page="10"
  />
</template>
```

**That's it!** Just pass `api-url` and DXTable handles:
- AJAX requests with axios
- Sorting parameters
- Pagination parameters
- Data extraction from `response.data.data`
- Error handling

### Advanced: Custom Provider Function

For custom API logic (auth headers, data transformation, etc.), provide your own `provider`:

```vue
<script setup>
const customProvider = async (context) => {
  const response = await fetch('/api/products', {
    headers: { 'Authorization': `Bearer ${token}` },
    ...
  });
  const json = await response.json();
  return json.items; // Custom response structure
};
</script>

<template>
  <DXTable :provider="customProvider" :fields="fields" />
</template>
```

### Provider Function Details

The provider function receives a context object:

```typescript
interface BTableProviderContext {
  sortBy?: BTableSortBy[];      // Current sort state
  filter?: string;               // Filter string (if filtering enabled)
  currentPage: number;           // Current page number
  perPage: number;               // Items per page
}
```

**Important:**
- Return an array of items (or Promise that resolves to array)
- BTable handles pagination UI automatically
- No need to show "Showing X to Y" text (provider mode)
- Sorting and pagination trigger automatic provider calls

### Adding Filters

Add inline filters by specifying `filter` in field definitions:

```typescript
const fields = [
  { key: 'sku', label: 'SKU', sortable: true },
  { key: 'name', label: 'Name', sortable: true, filter: 'text' },
  { key: 'category', label: 'Category', sortable: true, filter: 'select', filterOptions: [
    { value: 'Electronics', text: 'Electronics' },
    { value: 'Clothing', text: 'Clothing' },
    { value: 'Books', text: 'Books' },
  ]},
  { key: 'price', label: 'Price', sortable: true, filter: 'number' },
  { key: 'stock', label: 'Stock', sortable: true, filter: 'number' },
];
```

**Filter Types:**
- `'text'` - Text input with 300ms debounce for LIKE searches
- `'select'` - Dropdown with options (automatically adds "All" option)
- `'number'` - Number input for exact matches
- `'date'` - Date input for date filtering
- `false` or omit - No filter for this column

Filters appear inline beneath the table headers and trigger server requests automatically.

### Field Hints

Add helpful hint text below column headers to guide users:

```typescript
const fields = [
  { key: 'sku', label: 'SKU', sortable: true, hint: 'Product code' },
  { key: 'name', label: 'Name', sortable: true, filter: 'text', hint: 'Search by name' },
  { key: 'price', label: 'Price', sortable: true, hint: 'USD', formatter: (value) => `$${value}` },
  { key: 'stock', label: 'Stock', sortable: true, hint: 'Current inventory' },
];
```

**Features:**
- Hint text appears below the column label in a smaller, muted font
- Works with sortable columns (hint appears above sort indicators)
- Works with filters (hint appears in column header, above filter input)
- Useful for units (USD, kg), instructions (Search by name), or context (Current inventory)
- Optional - only shows when `hint` property is provided

### Backend Filter Handling

Update your controller to accept and apply filters:

```php
public function apiIndex(Request $request)
{
    $page = $request->input('page', 1);
    $perPage = $request->input('perPage', 10);
    $sortBy = $request->input('sortBy', 'created_at');
    $sortOrder = $request->input('sortOrder', 'desc');

    // Build query with filters
    $query = Product::query();
    $filters = $request->input('filters', []);

    // Text filters (LIKE search)
    if (!empty($filters['name'])) {
        $query->where('name', 'LIKE', '%' . $filters['name'] . '%');
    }

    // Exact match filters
    if (!empty($filters['category'])) {
        $query->where('category', $filters['category']);
    }

    if (!empty($filters['price'])) {
        $query->where('price', '=', $filters['price']);
    }

    // Whitelist sort columns
    $allowedSortColumns = ['sku', 'name', 'price', 'stock', 'created_at'];
    if (!in_array($sortBy, $allowedSortColumns)) {
        $sortBy = 'created_at';
    }

    $products = $query->orderBy($sortBy, $sortOrder)
        ->paginate($perPage, ['*'], 'page', $page);

    return response()->json([
        'data' => $products->items(),
        'pagination' => [
            'current_page' => $products->currentPage(),
            'per_page' => $products->perPage(),
            'total' => $products->total(),
            'from' => $products->firstItem(),
            'to' => $products->lastItem(),
            'last_page' => $products->lastPage(),
        ],
    ]);
}
```

**Filter Behavior:**
- Text filters automatically debounce (300ms) to reduce server load
- Filtering resets to page 1
- Empty filters are removed from request
- Filters preserve sort state

### Manual Refresh

Access the `refresh()` method for manual data reloading:

```vue
<script setup>
import { ref } from 'vue';

const tableRef = ref(null);

const refreshData = () => {
  tableRef.value?.refresh();
};
</script>

<template>
  <DButton @click="refreshData">Refresh</DButton>
  <DXTable
    ref="tableRef"
    :provider="fetchProducts"
    :fields="fields"
  />
</template>
```

## Inertia Mode (Alternative)

If your application already uses Inertia.js and you prefer server-side page props, you can use Inertia mode instead of API mode.

### When to Use Inertia Mode

- Your app is built entirely with Inertia.js
- You want the browser URL to update with sort/filter/page parameters
- You're already using `PaginatedResource` for other Inertia pages

### Laravel Backend (Inertia)

```php
<?php

namespace App\Http\Controllers;

use App\Models\Product;
use Illuminate\Http\Request;
use Inertia\Inertia;
use OmniTend\LaravelDashboard\Http\Resources\PaginatedResource;

class ProductController extends Controller
{
    public function index(Request $request)
    {
        $perPage = $request->input('perPage', 10);
        $sortBy = $request->input('sortBy', 'created_at');
        $sortOrder = $request->input('sortOrder', 'desc');

        // Whitelist allowed sort columns
        $allowedSortColumns = ['sku', 'name', 'price', 'stock', 'created_at'];
        if (!in_array($sortBy, $allowedSortColumns)) {
            $sortBy = 'created_at';
        }

        $products = Product::orderBy($sortBy, $sortOrder)->paginate($perPage);

        return Inertia::render('Products/Index', [
            'products' => new PaginatedResource($products),
        ]);
    }
}
```

### Vue Frontend (Inertia)

```vue
<script setup lang="ts">
import { DXTable } from '@omnitend/dashboard-for-laravel';
import type { PaginationData } from '@omnitend/dashboard-for-laravel';

interface Product {
  id: number;
  sku: string;
  name: string;
  price: string;
  stock: number;
}

interface Props {
  products: PaginationData & { data: Product[] };
}

defineProps<Props>();

const fields = [
  { key: 'sku', label: 'SKU', sortable: true },
  { key: 'name', label: 'Name', sortable: true },
  { key: 'price', label: 'Price', sortable: true },
  { key: 'stock', label: 'Stock', sortable: true },
];
</script>

<template>
  <DXTable
    title="Products"
    :items="products.data"
    :fields="fields"
    :pagination="products"
    inertia-url="/"
  />
</template>
```

**Key differences from API mode:**
- Pass data via `:items` and `:pagination` props (from Inertia page props)
- Use `inertia-url` instead of `api-url`
- URL updates when sorting/filtering/paginating
- Uses `:loading` prop instead of `v-model:busy`

### Custom Event Handlers (No Auto-Navigation)

If you need custom behavior, omit `inertia-url` and handle events manually:

```vue
<DXTable
  :items="products.data"
  :fields="fields"
  :pagination="products"
  @page-change="customPageHandler"
  @sort-change="customSortHandler"
/>
```

## TableField Interface

Fields support the following properties:

```typescript
interface TableField {
  key: string;                    // Required: Field key (matches data property)
  label?: string;                 // Column header label
  sortable?: boolean;             // Enable sorting for this column
  hint?: string;                  // Hint text below column header
  filter?: FilterType;            // Filter type: 'text' | 'select' | 'number' | 'date' | false
  filterOptions?: FilterOption[]; // Options for select filters
  filterPlaceholder?: string;     // Placeholder for filter input
  formatter?: (value: any, key: string, item: any) => string; // Custom formatter function
  [key: string]: any;             // Any other Bootstrap Vue Next BTable field props
}
```

## Edit Modals

Enable inline editing by providing `editFields` and `editUrl`:

```vue
<script setup>
const fields = [
  { key: 'name', label: 'Product Name', sortable: true },
  { key: 'price', label: 'Price', sortable: true },
];

const editFields = [
  { key: 'name', label: 'Product Name', type: 'text', required: true },
  { key: 'description', label: 'Description', type: 'textarea' },
  { key: 'price', label: 'Price', type: 'number', required: true },
  { key: 'stock', label: 'Stock', type: 'number', required: true },
];
</script>

<template>
  <DXTable
    :items="products.data"
    :fields="fields"
    :edit-fields="editFields"
    edit-url="/api/products/:id"
    edit-modal-title="Edit Product"
  />
</template>
```

**Features:**
- Click any row to open edit modal
- Form fields auto-populated from row data
- Save button submits PUT request to `editUrl` (`:id` replaced with item.id)
- Success/error toasts shown automatically
- Table refreshes after successful save
- Validation errors displayed inline

## Delete Functionality

Enable deletion with the `deleteUrl` prop:

```vue
<template>
  <DXTable
    :items="products.data"
    :fields="fields"
    :edit-fields="editFields"
    edit-url="/api/products/:id"
    delete-url="/api/products/:id"
    @row-deleted="handleDeleted"
    @delete-error="handleDeleteError"
  />
</template>
```

**Features:**
- Delete button appears in modal footer (red/danger variant)
- Confirmation dialog before deletion
- Success/error toasts with server messages
- Table auto-refreshes after successful deletion
- Displays server validation errors (e.g., "Cannot delete. This category has 42 products.")

**Backend Example:**
```php
public function destroy(Product $product)
{
    // Optional: Add validation
    if ($product->orders()->count() > 0) {
        return response()->json([
            'message' => "Cannot delete {$product->name}. This product has orders.",
        ], 422);
    }

    $product->delete();

    return response()->json([
        'success' => true,
        'message' => 'Product deleted successfully',
    ]);
}
```

## Extended Component

This is a custom component that extends beyond simple Bootstrap Vue Next wrappers,
providing additional functionality specific to Laravel dashboards.
